name: Install Certificate
description: Installs a certificate in the keychain.
author: Simon B. StÃ¸vring
inputs:
  certificate-password:
    description: Password for the certificate.
    required: true
  certificate-base64:
    description: Base64-encoded certificate (.p12).
    required: false
  certificate-file:
    description: Path to a certificate file (.p12).
    required: false
  keychain-name:
    description: Name of the keychain to add the certificate to. The keychain will be created if it does not exist.
    required: false
    default: build.keychain
  keychain-password:
    description: Password of the keychain to add the certificate to. Fallback to a randomly generated password if not set or empty.
    required: false
  set-default-keychain:
    description: Set the keychain as the default keychain.
    required: false
    default: true
runs:
  using: composite
  steps:
    - name: Install Certificate
      run: |
        set -euo pipefail
        CERTIFICATE_PASSWORD="${{ inputs.certificate-password }}"
        CERTIFICATE_FILE_PATH=$(mktemp)
        CERTIFICATE_SOURCE_DESCRIPTION=""
        INPUT_KEYCHAIN_PASSWORD_VALUE="${{ inputs.keychain-password }}"
        KEYCHAIN_PASSWORD="${INPUT_KEYCHAIN_PASSWORD_VALUE:-$(uuidgen)}"
        KEYCHAIN_NAME="${{ inputs.keychain-name }}"
        KEYCHAIN_PATH="/Users/$(whoami)/Library/Keychains/${KEYCHAIN_NAME}"
        KEYCHAIN_DB_PATH="${KEYCHAIN_PATH}-db"
        if [ -z "$CERTIFICATE_PASSWORD" ]; then
          echo "::error::The password for the certificate cannot be empty."
          exit 1
        fi
        if [[ -n "${{ inputs.certificate-base64 }}" ]]; then
          CERTIFICATE_SOURCE_DESCRIPTION="certificate-base64 input"
          printf '%s' "${{ inputs.certificate-base64 }}" | openssl base64 -d -A -out "$CERTIFICATE_FILE_PATH"
        elif [[ -n "${{ inputs.certificate-file }}" ]]; then
          eval certificate_file="${{ inputs.certificate-file }}"
          CERTIFICATE_SOURCE_DESCRIPTION="certificate file at $certificate_file"
          cp "$certificate_file" "$CERTIFICATE_FILE_PATH"
        else
          echo "Error: Provide certificate-base64 or certificate-file."
          exit 1
        fi
        CERTIFICATE_PEM_PATH=$(mktemp)
        OPENSSL_VERSION=$(openssl version)
        if echo "$OPENSSL_VERSION" | grep -qE 'OpenSSL 3'; then
          OPENSSL_PKCS12_FLAGS="-legacy"
        else
          OPENSSL_PKCS12_FLAGS=""
        fi
        if ! openssl pkcs12 $OPENSSL_PKCS12_FLAGS -in "$CERTIFICATE_FILE_PATH" -clcerts -nokeys -passin pass:"$CERTIFICATE_PASSWORD" -out "$CERTIFICATE_PEM_PATH" 2>&1; then
          echo "::error::Failed to read certificate file. Check that the certificate and password are correct."
          rm -f "$CERTIFICATE_PEM_PATH"
          exit 1
        fi
        CERTIFICATE_EXPIRY=$(openssl x509 -in "$CERTIFICATE_PEM_PATH" -noout -enddate | cut -d= -f2)
        if ! command -v date >/dev/null 2>&1; then
          echo "::error::The date command is required to validate the certificate expiry."
          rm -f "$CERTIFICATE_PEM_PATH"
          exit 1
        fi
        CERTIFICATE_EXPIRY_EPOCH=$(date -d "$CERTIFICATE_EXPIRY" +%s 2>/dev/null || date -j -f "%b %d %H:%M:%S %Y %Z" "$CERTIFICATE_EXPIRY" "+%s" 2>/dev/null)
        if [ -z "$CERTIFICATE_EXPIRY_EPOCH" ]; then
          echo "::error::Unable to parse the certificate expiry date: $CERTIFICATE_EXPIRY."
          rm -f "$CERTIFICATE_PEM_PATH"
          exit 1
        fi
        CURRENT_EPOCH=$(date -u +%s)
        if [ "$CERTIFICATE_EXPIRY_EPOCH" -le "$CURRENT_EPOCH" ]; then
          echo "::error::The certificate (${CERTIFICATE_SOURCE_DESCRIPTION:-certificate}) has expired on $CERTIFICATE_EXPIRY."
          rm -f "$CERTIFICATE_PEM_PATH"
          exit 1
        fi
        if ! openssl x509 -in "$CERTIFICATE_PEM_PATH" -noout -checkend 2592000 >/dev/null 2>&1; then
          echo "::warning::The certificate (${CERTIFICATE_SOURCE_DESCRIPTION:-certificate}) will expire soon (on $CERTIFICATE_EXPIRY)."
        fi
        if [ ! -f "$KEYCHAIN_DB_PATH" ]; then
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychains -d user -s $KEYCHAIN_DB_PATH $(security list-keychains -d user | sed s/"//g)
          security set-keychain-settings "$KEYCHAIN_NAME"
        fi
        security import "$CERTIFICATE_FILE_PATH" -k "$KEYCHAIN_NAME" -f pkcs12 -A -T /usr/bin/codesign -T /usr/bin/security -P "$CERTIFICATE_PASSWORD"
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        if [ "${{ inputs.set-default-keychain }}" = true ]; then
          security default-keychain -s $KEYCHAIN_PATH
        fi
        rm -f "$CERTIFICATE_PEM_PATH"
        rm -f "$CERTIFICATE_FILE_PATH"
      shell: bash
